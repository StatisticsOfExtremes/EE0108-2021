library("glmnet")
install.packages("glmnet")
knitr::opts_chunk$set(echo = TRUE)
dados <- read.csv("house_data_exer_tnkc_wobasement.csv")
dados <- read.csv("house_data_exer_tnkc_wobasement.csv")
head(dados)
head(dados)
View(dados)
library(plyr)
?rename
colnames(dados)
dados %>%
rename(ï..price = price)
library(dplyr)
dados %>%
rename(ï..price = price)
dados %>%
rename(price = ï..price)
View(dados)
dados %>%
rename(price = ï..price)
View(dados)
dados %>%
rename(price = "ï..price")
names(dados)[1] <- "price"
library("glmnet")
library("tidyr")
library("dplyr")
library("plyr")
library("glmnet")
library("tidyr")
library("dplyr")
library("plyr")
library(glmnet)
library(dplyr)
knitr::opts_chunk$set(echo = TRUE)
library(glmnet)
library(dplyr)
library(glmnet)
library(dplyr)
library(dplyr)
library(dplyr)
library(dplyr)
library(dplyr)
library(glmnet)
library(dplyr)
library(glmnet)
library(dplyr)
library(glmnet)
library(dplyr)
## separamos os dados entre treino e teste para evitar overfitting
index <- sample(nrow(dados),nrow(dados)*0.80)
dados.train <- dados[index,]
dados.test <- dados[-index,]
index_y <- which(colnames(dados)=="price")
#Como o pacote `gmlnet` não aceita dataframes, precisamos converter
#os dados para matrix
X.train <- as.matrix(dados.train[,-index_y])
Y.train <- as.matrix(dados.train[,index_y])
X.test <- as.matrix(dados.test[,-index_y])
Y.test <- as.matrix(dados.test[,index_y])
ridge.fit <- glmnet(x= X.train, y=Y.train, family="gaussian", alpha=0)
plot(ridge.fit, xvar="Lambda", label=TRUE)
ridge.fit <- glmnet(x= X.train, y=Y.train, family="gaussian", alpha=0)
plot(ridge.fit, xvar="lambda", label=TRUE)
cv.ridge <-  cv.glmnet(x=X.train, y=Y.train, family="gaussian", alpha=0, nfolds=10)
plot(cv.ridge)
coef(cv.ridge, s=cv.ridge$lambda.min)
Y_pred.ridge <- predict(ridge.fit, newx = X.test, s=cv.ridge$lambda.min)
MSE_ridge=mean((Y.test-Y_pred.lasso)^2)
ridge.fit <- glmnet(x= X.train, y=Y.train, family="gaussian", alpha=0)
plot(ridge.fit, xvar="lambda", label=TRUE)
cv.ridge <-  cv.glmnet(x=X.train, y=Y.train, family="gaussian", alpha=0, nfolds=10)
plot(cv.ridge)
coef(cv.ridge, s=cv.ridge$lambda.min)
Y_pred.ridge <- predict(ridge.fit, newx = X.test, s=cv.ridge$lambda.min)
MSE_ridge=mean((Y.test-Y_pred.ridge)^2)
